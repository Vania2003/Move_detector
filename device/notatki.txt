mosquitto_sub -h localhost -t 'iot/eldercare/room1/motion/health' -v
ssh pi@raspberrypi.local
→ Login — pi
→ Hasło — raspberry
vcgencmd measure_temp
amni ikyo ulpj osas
sudo chown -R pi:pi /home/pi/DYPLOM/device/raspberry
sudo systemctl stop rules-engine notifier
sudo systemctl start rules-engine notifier

1) Картина целиком
Задача системы: принимать события от PIR-датчиков (ESP8266) через MQTT, логировать их в SQLite, запускать правила выявления аномалий (INACTIVITY, DWELL_CRITICAL и т.п.), создавать алерты и рассылать уведомления (email), а также отдавать историю/состояние через HTTP API (Flask). Дополнительно есть симулятор и сценарные тесты.

Основные компоненты:

ESP8266 (Arduino/PlatformIO) → публикует MQTT-сообщения (motion/state, motion/health).

Mosquitto (MQTT брокер) → принимает и раздаёт топики.

MQTT→SQLite логгер (mqtt_logger.py) → подписан на топики, пишет:

«сырые» сообщения — messages_raw,

движения — motion_events,

пульсы здоровья — heartbeats,

регистрирует устройство/комнату — devices/rooms.

Правила (rules_engine.py) → периодически читает БД и:

открывает/закрывает alerts (INACTIVITY, DWELL_CRITICAL, NO_HEARTBEAT),

опирается на пороги из rule_settings.

Уведомления (notifier.py) → опрашивает alerts и шлёт email с логированием результата в notifications_log.

HTTP API (app.py, Flask) → удобный просмотр последних сообщений/алертов/девайсов.

Симулятор и тесты → publish_sim.py (интерактивный), run_tests.sh (пакет тестов).

Сервисные скрипты → деплой (push/pull), обслуживание SQL, миграции.

2) Структура проекта на Raspberry Pi

Папка: /home/pi/DYPLOM/device/raspberry

app.py                    # Flask API (порт 5000)
db_maintenance.sql        # служебные SQL-задачи (очистки/индексы и т.п.)
mqtt_listener.py          # (исторический вспомогательный скрипт)
mqtt_logger.py            # основной MQTT→SQLite логгер
rules_engine.py           # движок правил
notifier.py               # отправка email-уведомлений по алертам
publish_sim.py            # интерактивный генератор MQTT-событий (симулятор)
run_tests.sh              # пакетная прогонка 10 сценариев
schema.sql                # схема БД и миграции (DDL)
events.db                 # сама база SQLite (+ WAL/SHM)
events.db-wal / .db-shm   # WAL/SHM для SQLite
events_backup_*.db        # резервные копии


Сервисные unit-файлы (в системе):

/etc/systemd/system/mqtt-logger.service   # MQTT → SQLite
/etc/systemd/system/rules-engine.service  # Движок правил
/etc/systemd/system/notifier.service      # Уведомления
# опционально: override conf с Environment= для SMTP

3) MQTT — топики и полезная нагрузка

Топики (ESP → брокер):

iot/eldercare/<room>/motion/state

{"device":"esp8266_test","motion":true|false}


(в симуляторе дополнительно отправляем ts для воспроизводимости, ESP шлёт без ts — время проставляет брокер/логгер).

iot/eldercare/<room>/motion/health

{"device":"esp8266_test","uptime_ms": 1234567}


При старте ESP посылает «boot» с IP (ретейн).

Учёт в БД:

все сообщения попадают в messages_raw;

движения — в motion_events (булево как value=0/1);

пульсы — в heartbeats;

по первым событиям регистрируем device/room в devices/rooms.

4) База данных (SQLite, events.db)
Основные таблицы

messages_raw

id INTEGER PK, ts_utc TEXT ISO8601, topic TEXT, payload TEXT


motion_events

id INTEGER PK,
ts_utc TEXT ISO8601,         -- важно: 'YYYY-MM-DDTHH:MM:SS'
device_id TEXT NOT NULL,
value INTEGER NOT NULL CHECK (value IN (0,1))
INDEX idx_motion_dev_ts(device_id, ts_utc)


heartbeats

id INTEGER PK,
ts_utc TEXT '%Y-%m-%d %H:%M:%S' или ISO8601,
device_id TEXT NOT NULL,
uptime_ms INTEGER NULL


devices

device_id TEXT PK,
room TEXT NULL,              -- добавлена колонка room TEXT (маппинг девайс→комната)
... (могут быть доп. поля)


rooms

id INTEGER PK,
name TEXT UNIQUE


alerts

id INTEGER PK,
ts_utc TEXT,                 -- время события/открытия правила
room TEXT,                   -- логическое имя комнаты
device_id TEXT,              -- иногда вместо room для NO_HEARTBEAT
type TEXT,                   -- "INACTIVITY", "DWELL_CRITICAL", "NO_HEARTBEAT", ...
severity TEXT,               -- "high" / "medium" ...
details TEXT,                -- пояснение (минуты/секунды и т.п.)
status TEXT,                 -- 'open'|'closed'
created_at TEXT,             -- штамп создания
closed_at TEXT NULL,         -- штамп закрытия
ack_at TEXT NULL, ack_by TEXT NULL,
notified_at TEXT NULL,       -- когда впервые уведомили
channels TEXT NULL,          -- "email,telegram" (на будущее)
rule TEXT NULL,              -- человекочитаемый ключ правила
params TEXT NULL             -- JSON с параметрами правила (на будущее)


rule_settings — конфигурация порогов правил (K/V)

id INTEGER PK, key TEXT UNIQUE, value TEXT
# текущие значения:
inactive.threshold_day_min = 0.5
inactive.threshold_night_min = 1
night.window = 23:00-06:00
dwell.critical_rooms = Bathroom,Kitchen
dwell.bathroom_min = 0.3
dwell.kitchen_min = 0.5
dwell.gap_min = 2
pattern.window_days = 14
pattern.z_threshold = 2.5


notifications_log — журнал попыток уведомлений

id INTEGER PK,
alert_id INTEGER,
channel TEXT,                -- 'email'
sent_at TEXT,
ok INTEGER,                  -- 1/0
err TEXT NULL


daily_stats — задел под агрегации (сейчас опционально).

Примечание по времени: у нас в БД встречаются обе формы (YYYY-MM-DDTHH:MM:SS и YYYY-MM-DD HH:MM:SS). В коде правил мы учли это с помощью parse_ts().

5) Службы (systemd)
mqtt-logger.service

Подписывается на MQTT-топики и пишет в БД.

Автозапуск, рестарт при падении.

rules-engine.service

Каждые CHECK_INTERVAL секунд (сейчас 15) читает БД и:

INACTIVITY — нет движения дольше порога (день/ночь из rule_settings).

DWELL_CRITICAL — повышенная активность в критичных комнатах за окно.

NO_HEARTBEAT — нет пульса девайса > 30 минут.

Открывает/закрывает записи в alerts (без дублей по открытому состоянию).

Учёт day/night по night.window.

Парсинг времени совместим с ISO и с пробелом.

notifier.service

Каждую минуту ищет alerts.status='open' AND notified_at IS NULL и пытается отправить email.

Записывает результат в notifications_log, проставляет alerts.notified_at при успехе.

Настроено через drop-in override.conf (Environment=SMTP_* / ALERT_EMAIL).

Для Gmail используется App Password (а не обычный пароль).

Быстро отключить уведомления:
sudo systemctl stop notifier (правила и логирование продолжат работать).

6) HTTP API (Flask, app.py)

Сервис слушает порт 5000 (и, судя по логу, уже запущен как фоновый процесс).
Быстрые проверки:

GET /
→ {"status":"ok","message":"Eldercare API active"}

GET /api/messages?limit=N
→ последние N сырых MQTT сообщений: ts_utc, topic, payload.

GET /api/health/latest
→ по каждому device_id: last_hb и максимум uptime_ms.

GET /api/devices
Замечание: изначально делал LEFT JOIN rooms r ON r.id = d.room_id.
Мы добавили devices.room TEXT, поэтому к запросу стоит вернуться (см. ниже To-Do).

GET /api/alerts
→ список открытых алертов: id, ts_utc, room, device_id, type, severity, status, details.

Позже, для фронтенда, добавим:

POST /api/alerts/:id/ack|close,

GET /api/rules / PUT /api/rules,

фильтры/пагинацию для истории и т.д.

7) Симуляция и тесты
publish_sim.py

Интерактивный TUI для публикации событий в MQTT:

режимы: morning/day/night/bathroom_long/kitchen_cooking/random/manual,

можно указать room / device_id / duration,

полезно для демонстрации работы правил и API.

run_tests.sh

Пакет из 10 коротких сценариев:

утро/день/ночь, длительное пребывание в ванной, кухня, ручной on/off, inactivity → recovery, «случайная активность», финальная сводка,

каждый сценарий публикует MQTT-последовательности через publish_sim.py, ждёт краткие паузы и проверяет БД/алерты,

выводит компактный отчёт по триггерам (мы уже видели «✅ INACTIVITY triggered …», «✅ DWELL_CRITICAL …» и закрытие алерта «recovery»).

8) ESP8266 (Arduino/PlatformIO)

Главное:

Подключение к Wi-Fi (wifiEnsure).

Подключение к MQTT (mqttEnsure) с учётом логина/пароля.

PIR-обработка:

тёплый старт PIR_WARMUP_MS (игнор первых 30 сек),

антидребезг EDGE_DEBOUNCE,

обязательный стабильный LOW NEED_LOW_MS перед новой посылкой HIGH,

публикация motion=true/false в TOPIC_STATE, моргание LED.

Пульс здоровья каждые 5 секунд (TOPIC_HEALTH с uptime_ms).

В include/config.h задаём:

WIFI_SSID / WIFI_PASS
MQTT_HOST / MQTT_PORT / MQTT_USER / MQTT_PASS
DEVICE_ID
TOPIC_HEALTH / TOPIC_STATE (включая «room1»)


pir.h/.cpp — модульная логика датчика (дебаунс/порог).

Мы физически проверили: при махе рукой в API видим череду motion:true/false и растущий uptime_ms. Значит связка ESP → MQTT → логгер → БД → API рабочая.

9) Что уже доказано тестами и руками

MQTT соединение и формат payload устойчивы.

Логгер пишет в messages_raw, motion_events, heartbeats.

Правила запускаются, открывают/закрывают INACTIVITY, детектят DWELL_CRITICAL.

Email-уведомления реально уходят (видно в почте и в notifications_log, проставляется alerts.notified_at).

Быстрые «живые» тесты PIR на столе → API отражает изменения.

10) Известные тонкости/решения, которые мы уже внедрили

Форматы времени: в motion_events.ts_utc мы используем ISO8601 (…T…). В правиле — парсинг обеих форм (ISO / с пробелом).

motion_events без room: мы не добавляли room в эту таблицу, вместо этого в правилах делаем JOIN devices ON m.device_id = d.device_id и фильтруем по d.room. Это правильная нормализация.

Миграции: schema.sql раньше падал на DEFAULT для ALTER TABLE ... ADD COLUMN. Мы починили миграции простыми ADD COLUMN + отдельным UPDATE.

Права файлов при деплое с Windows: были ошибки scp: Permission denied из-за корневых владельцев и/или открытых файлов. Решение — копировать во временную папку и sudo mv или использовать rsync с --rsync-path="sudo rsync". (Мы давали обновлённые скрипты push/pull.)

11) Что осталось/To-Do перед фронтендом

Обязательное (коротко):

Подчистить висящие «NO_HEARTBEAT» из ранних тестов (старые муляжи):

DELETE FROM alerts WHERE type='NO_HEARTBEAT' AND details='no heartbeat ever';


/api/devices — обновить запрос под devices.room TEXT. Простой вариант:

SELECT d.device_id,
       d.room AS room,
       (SELECT MAX(ts_utc) FROM heartbeats h WHERE h.device_id=d.device_id) AS last_hb
FROM devices d
ORDER BY last_hb DESC;


Управление алертами (на потом фронту):

POST /api/alerts/<id>/ack (помечать «в работе»: ack_at, ack_by),

POST /api/alerts/<id>/close (закрывать вручную),

GET /api/alerts?status=open|closed&room=...&type=...&since=....

Безопасность (минимум):

Mosquitto: отдельный пользователь/пароль, ACL по топикам.

Flask API: хотя бы базовая авторизация/токен.

Бэкапы и ротация:

ночной sqlite3 VACUUM;/ротация messages_raw,

cron для events_backup_%F_%H-%M.db + удаление старых.

Желательно:

Реализовать правило NIGHT_ACTIVITY и PATTERN_SHIFT (скелеты у нас готовы: есть night.window, pattern.window_days, pattern.z_threshold — добавить расчёты).

Нормализовать хранение времени: строго ISO8601 (и это же показывать в API).

Добавить systemd unit для app.py (сейчас API запущен, но без unit — привести к единому стилю).

Небольшой CLI (iot start|stop|status) для управления rules-engine/notifier.

12) Мини-«памятка эксплуатации»

Остановить рассылку:
sudo systemctl stop notifier

Полностью «усыпить» обработку:
sudo systemctl stop rules-engine notifier

Запустить всё:
sudo systemctl start mqtt-logger rules-engine notifier

Проверить датчик вживую (1-минутный тест):

Убедись, что службы включены:
sudo systemctl start mqtt-logger rules-engine

Помаши рукой перед PIR → затем:
curl http://localhost:5000/api/messages?limit=5
(увидишь motion:true/false и uptime_ms).

SELECT * FROM motion_events ORDER BY id DESC LIMIT 5; — убедиться, что запись в БД есть.

Если включён notifier — можешь получить письмо (лучше держать его остановленным в разработке).

13) Где мы относительно изначального плана

(0) Синхронизация payload на ESP — ✅ (формат JSON согласован, стабильный).
(1) Миграция БД + rule_settings и notifications_log — ✅ (оба есть, миграции отлажены).
(2) Правила: INACTIVITY — ✅; DWELL_CRITICAL — ✅; NIGHT_ACTIVITY/PATTERN_SHIFT — ⚙️ готовы базы, осталось дописать логику.
(3) Сервис notifier.py + systemd — ✅ (email отправляется, логируется).
(4) Мини-симулятор профилей — ✅ (publish_sim.py) + пакет тестов run_tests.sh.
(5) Расширение API — 🟡 базовые эндпоинты есть; ack/close/filters — в следующем шаге.
(6) Безопасность MQTT и API — 🟡 базовый логин в MQTT есть; ACL/токен к API — next.
(7) Логи и бэкапы — 🟡 частично (journald + резервные копии вручную; оформить cron).
(8) UI-минимум (React) — ⏭ как раз следующий блок.
(9) Документация — 🟡 (данный документ — основа, надо положить в README.md).
(10) Испытания и отчёт — 🟡 идёт: у нас есть симулятор + реальный датчик, осталось собрать сценарии и результаты.

14) Что я предлагаю сделать прямо перед фронтендом

Маленький PR в app.py для /api/devices (см. п. 11.2).

Добавить POST /api/alerts/<id>/ack|close (фронту понадобятся экшены).

Снять «висящие» тестовые NO_HEARTBEAT.

Зафиксировать README.md: запуск/остановка, эндпоинты, схема БД.

Включить notifier только на демо — по умолчанию держать остановленным в разработке.

Очистили старый шум «NO_HEARTBEAT»
Сделали аккуратную чистку через WAL-чекпоинт и транзакцию, чтобы не ловить database is locked. Больше «вечных» NO_HEARTBEAT от ранних тестов нет.

Резервные копии SQLite (скрипт + cron)

Создан /usr/local/bin/eldercare_backup.sh с PRAGMA wal_checkpoint(FULL) и таймаутом на блокировки.

Прогон вручную прошёл успешно — получили свежие events_backup_YYYY-MM-DD_HH-MM.db.

В crontab добавлены:

03:30 — бэкап БД скриптом.

04:00 — db_maintenance.sql (интегритет/индексы/чистки).

Защитили API токеном (минимальная авторизация)

Для всех /api/* внедрена проверка заголовка Authorization: Bearer secret123.

Без заголовка теперь корректно отдаёт 401 Unauthorized (видно по /api/messages и /api/devices).

С токеном — всё работает (проверяли на /api/alerts).

Установлен jq для удобных CLI-пайплайнов

Теперь можно быстро фильтровать/закрывать пачки алертов из консоли.

Колонка devices.room и привязка комнат

Добавили ALTER TABLE devices ADD COLUMN room TEXT;

Заполнили маппинг девайс→комната.

Логику правил перевели на JOIN по devices (нормализовано; motion_events остаётся без колонки room).

Rules Engine — устойчивый парсинг времени и корректные запросы

Унифицирован парсинг времени (parse_ts) — понимает и YYYY-MM-DDTHH:MM:SS, и с пробелом.

Получение «последнего движения» теперь через JOIN motion_events↔devices по device_id.

Исправлены обращения к несуществующим колонкам (room/motion) и несоответствия формату времени.

Проверка «вживую» на PIR/ESP

Убедились, что публикации motion true/false и health uptime_ms доходят до messages_raw и видны через API.

Включённые правила создают/закрывают алерты по живым данным.

Гашение почтового спама на время разработки

notifier оставляем остановленным, чтобы фронт не «засыпало» письмами. Включим только на демо.

API /devices — напоминание на правку

Мы зафиксировали, что запрос надо обновить на использование devices.room и подзапроса по heartbeats. (Готовы внести сразу, когда скажешь: это 3–4 строки SQL.)

Идея и назначение

Система «умного присмотра» для квартиры пожилого человека:

недорогие PIR-датчики движения (ESP8266) → публикуют события в MQTT (Mosquitto);

Raspberry Pi принимает и логирует всё в SQLite, периодически прогоняет правила (rules_engine) → открывает/закрывает alerts (INACTIVITY, DWELL_CRITICAL, NO_HEARTBEAT);

Flask HTTP API отдаёт историю/состояние;

Веб-панель (React) показывает состояние, даёт фильтры/экспорт/кнопки «Ack/Close», базовые настройки правил.

Сквозной workflow (end-to-end)

Движение: PIR ловит движение → ESP8266 шлёт MQTT (iot/eldercare/<room>/motion/state с motion:true/false).

Пульс устройства: ESP шлёт health/heartbeat (…/motion/health, uptime_ms и device id).

MQTT-логгер (на Pi) пишет в SQLite:
messages_raw, motion_events, heartbeats, регистрирует devices/rooms.

Rules Engine раз в N секунд просматривает БД → открывает/закрывает alerts:

INACTIVITY — нет движения слишком долго (день/ночь — разные пороги);

DWELL_CRITICAL — подозрительно длинное пребывание в «критичной» комнате (напр. ванная);

NO_HEARTBEAT — устройство молчит.

(Опционально) Notifier рассылает email при критике.

Веб-панель:

History — сырые сообщения/движения/heartbeat, фильтры, CSV;

Devices — устройства + их последний heartbeat (UP/DOWN);

Alerts — список, фильтры, Ack/Close, Drawer с деталями, CSV, bulk-close для NO_HEARTBEAT;

Settings — пороги правил (чтение/сохранение).

Что уже «живое», а что ещё мок/заглушка
Страница/блок	Источник	Статус
Alerts (таблица, фильтры, Ack/Close, Drawer, CSV, Live-polling)	/api/alerts, POST /api/alerts/{id}/ack, POST /api/alerts/{id}/close, POST /api/alerts/close-bulk?…	РЕАЛЬНОЕ. Работает поверх фактических алертов из БД/правил.
History → вкладка Raw MQTT	/api/messages?limit=…	РЕАЛЬНОЕ. Показывает реальные сырые MQTT-сообщения.
History → Motion events	/api/motion_events?limit=…	РЕАЛЬНОЕ (при наличии логгера).
History → Heartbeats	/api/heartbeats?limit=…	РЕАЛЬНОЕ.
Devices (таблица + UP/DOWN по 30 мин)	/api/devices (+ локально isUp, timeAgo)	РЕАЛЬНОЕ — строится из последних heartbeat.
Settings (Rule settings)	GET/PUT /api/rule-settings	РЕАЛЬНОЕ — читает/сохраняет текущие пороги правил.
Dashboard → KPI: Open alerts, Devices	/api/alerts?status=open, /api/devices	РЕАЛЬНОЕ.
Dashboard → Latest MQTT table	/api/messages?limit=10	РЕАЛЬНОЕ.
Dashboard → мини-граф “Activity”	локальный массив	МОК (визуальный заполнитель; можно построить по реальной истории).
Rooms map (SVG-карточки комнат)	локальный массив ROOMS	МОК (визуализация/UX-скелет; клики/hover работают, но данные захардкожены).

Итог: «мясо» уже реальное — алерты / история / устройства / настройки. Заглушками остались только 2 визуальных элемента: мини-граф на дашборде и карта комнат.

Типичные сценарии использования

Оператор/родственник:

открывает Alerts, видит INACTIVITY / DWELL / NO_HEARTBEAT, фильтрует, сортирует, Ack для фиксации обработки, Close при нормализации, в Drawer — подробности и сырое JSON.

при всплеске фальш-позитивов по «сердцебиению» — Bulk close NO_HEARTBEAT (кнопка становится видимой/акцентной только когда уместно — мы это уже обсуждали).

Диагностика:

заходит в History, смотрит поток Raw/Motion/Heartbeats, экспортирует CSV.

Инвентаризация устройств:

Devices — кто «живой», когда был последний пульс, какая комната.

Админ/инженер:

правит пороги в Settings (день/ночь, критичные комнаты, окна анализа паттернов и т. п.).

Что ещё надо допилить (по списку приоритетов)

Rooms map (реальные данные)

подгрузить реальную разметку комнат (из /api/devices/rooms) и счётчики движений за последние X минут;

опционально: «тепловая карта» на основе плотности motion_events.

Мини-граф активности на Dashboard

построить из агрегированного /api/motion_events (например, гистограмма по часам за последние сутки).

Улучшения удобства (UX)

быстрые пресеты фильтров в Alerts («за час», «только INACTIVITY», «только открытые»);

сохранение состояния фильтров в URL/query (deep-linking).

Уведомления

если email-нотификации уже работают на Pi — добавить в Settings индикаторы статуса и тестовую кнопку «send test».