mosquitto_sub -h localhost -t 'iot/eldercare/room1/motion/health' -v
ssh pi@raspberrypi.local
→ Login — pi
→ Hasło — raspberry
vcgencmd measure_temp
hostname -I
amni ikyo ulpj osas
sudo chown -R pi:pi /home/pi/DYPLOM/device/raspberry
sudo systemctl stop rules-engine notifier
sudo systemctl start rules-engine notifier
sudo systemctl start mosquitto mqtt-logger rules-engine eldercare-api

sudo systemctl enable flask-api.service
sudo systemctl enable mqtt-logger.service
sudo systemctl enable rules-engine.service
sudo systemctl enable notifier.service
sudo systemctl status flask-api.service mqtt-logger.service rules-engine.service notifier.service

journalctl -u mqtt-logger -f
journalctl -u rules-engine -f
journalctl -u notifier -f
curl -s -H "X-API-Key: $KEY" $API/api/devices | jq . //lista urzadzen
curl -s -H "X-API-Key: $KEY" "$API/api/alerts?limit=5" | jq . //wydarzenia ruchu
curl -s -H "X-API-Key: $KEY" $API/api/rule-settings | jq . //aktualny prog

curl -s -X PUT -H "X-API-Key: $KEY" -H "Content-Type: application/json" \
  -d '{"inactive.threshold_day_min":"0.5","inactive.threshold_night_min":"1","night.window":"23:00-06:00"}' \
  $API/api/rule-settings | jq .  //noc na 0.5 minuty

curl -s -H "X-API-Key: $KEY" "$API/api/alerts?status=open&limit=5" | jq . //sprawdzenie

python3 simulator_motion.py
Room: room1
Device: esp8266_test
Mode: Bathroom long stay
Duration: 1 minuta

journalctl -u mqtt-logger -f (zdarzenia),
journalctl -u rules-engine -f (otwarcie DWELL_CRITICAL),
curl -s -H "X-API-Key: $KEY" "$API/api/alerts?status=open&limit=5" | jq .


iot/eldercare/<room>/motion/state → {"device":"<id>", "motion": true|false}
iot/eldercare/<room>/motion/health → {"device":"<id>", "uptime_ms": <int>}

Aplikacje/serwisy:

mqtt_logger.py — logger MQTT→SQLite (rejestruje też devices/rooms).
rules_engine.py — silnik reguł (INACTIVITY, DWELL_CRITICAL, NO_HEARTBEAT).
notifier.py — e-mail (ustawia alerts.notified_at, loguje w notifications_log).
app.py — Flask API (port 5000, token w nagłówku).

Symulacja/testy:

simulator_motion.py — interaktywny generator aktywności (profile: day/night/bathroom/kitchen/random/manual).
run_tests.sh — pakiet ~10 scenariuszy E2E (otwarcia/zamknięcia alertów).

Baza i DDL/utrzymanie:
events.db, events.db-wal, events.db-shm, events_backup_*.db
schema.sql — DDL + migracje (dodane kolumny w alerts, devices.room).
db_maintenance.sql — VACUUM/indeksy/retencja (np. cleanup starych alertów).

Inne:
mqtt_listener.py — historyczny listener do podglądu (dev).

Unit-files (systemd):
/etc/systemd/system/mqtt-logger.service
/etc/systemd/system/rules-engine.service
/etc/systemd/system/notifier.service
/etc/systemd/system/eldercare-api.service


DB:
Tabele (kluczowe pola + indeksy):
-rooms(id PK, name UNIQUE)
-devices(id PK, device_id UNIQUE, room_id FK, room TEXT, created_at TEXT)
-messages_raw(id PK, ts_utc TEXT, topic TEXT, device_id TEXT NULL, payload TEXT)
    Indeksy: idx_raw_ts(ts_utc), idx_raw_topic(topic), idx_raw_dev_ts(device_id, ts_utc)

-motion_events(id PK, ts_utc TEXT, device_id TEXT NOT NULL, value INTEGER CHECK (0,1))
    Indeks: idx_motion_dev_ts(device_id, ts_utc)


-heartbeats(id PK, ts_utc TEXT, device_id TEXT NOT NULL, ip TEXT NULL, uptime_ms INTEGER NULL)
    Indeks: idx_hb_dev_ts(device_id, ts_utc)

-alerts(id PK, ts_utc TEXT, room TEXT, device_id TEXT, type TEXT, severity TEXT, details TEXT, status TEXT DEFAULT 'open', created_at TEXT, closed_at TEXT NULL, ack_at TEXT NULL, ack_by TEXT NULL, notified_at TEXT NULL, channels TEXT NULL, rule TEXT NULL, params TEXT NULL)
    Indeksy: idx_alerts_status(status), idx_alerts_ts(ts_utc)

-rule_settings(id PK, key TEXT UNIQUE, value TEXT)

-notifications_log(id PK, alert_id INTEGER, channel TEXT, sent_at TEXT DEFAULT (datetime('now')), ok INTEGER, details TEXT)

-daily_stats(day TEXT, device_id TEXT, metric TEXT, value INTEGER, PRIMARY KEY(day, device_id, metric))


 Serwisy
mqtt-logger.service
Subskrybuje tematy MQTT i zapisuje dane do bazy.
Automatyczny start, ponowne uruchomienie po awarii.

rules-engine.service
Co CHECK_INTERVAL sekund (obecnie 15) odczytuje bazę i:

INACTIVITY — brak ruchu dłużej niż próg (różne progi dla dnia/nocy z rule_settings).

DWELL_CRITICAL — podwyższona aktywność w krytycznych pomieszczeniach w zadanym oknie czasu.

NO_HEARTBEAT — brak „pulsu” urządzenia > 30 minut.
Otwiera/zamyka wpisy w alerts (bez duplikatów dla już otwartych incydentów).
Uwzględnia dzień/noc na podstawie night.window.
Parsowanie czasu jest kompatybilne zarówno z ISO, jak i z formatem z odstępem (spacją).

notifier.service
Co minutę wyszukuje alerts.status='open' AND notified_at IS NULL i próbuje wysłać e-mail.
Zapisuje rezultat w notifications_log, a przy sukcesie ustawia alerts.notified_at.
Konfiguracja poprzez drop-in override.conf (zmienne środowiskowe SMTP_* / ALERT_EMAIL).
Dla Gmaila używany jest App Password (zamiast zwykłego hasła).

HTTP API (Flask, app.py)

HTTP API (Flask; auth: Authorization: Bearer <API_TOKEN> lub X-API-Key)
GET / — ping (status).

Dane:
GET /api/messages?limit= — ostatnie surowe MQTT.
GET /api/health/latest — ostatni HB/uptime per urządzenie.
GET /api/devices — urządzenia + room + last_hb (JOIN/Podzapytanie do heartbeats).

Urządzenia:
POST /api/devices/register — {device_id, room} (rejestr/aktualizacja).
DELETE /api/devices/<id>/unregister

Alerty:
GET /api/alerts?status=&type=&room=&last_minutes=&limit=
POST /api/alerts/<id>/ack (ustawia ack_at, ack_by)
POST /api/alerts/<id>/close (zamyka; closed_at)
POST /api/alerts/close-bulk?... (np. hurtowe zamknięcie NO_HEARTBEAT)

Ustawienia:
GET/PUT /api/rule-settings — odczyt/zmiana progów.
 CORS otwarty dla frontu lokalnego.